# pipex-WIP ♅
Summary: This project is the discovery in detail and by programming of a UNIX mechanism

## Objectives 

Your objective is to code the Pipex program.
It should be executed in this way:

``./pipex file1 cmd1 cmd2 file2``

Just in case: file1 and file2 are file names, cmd1 and cmd2 are shell commands with
their parameters.
<br>
<br>
The execution of the pipex program should do the same as the next shell command:
``< file1 cmd1 | cmd2 > file2``

## Allowed functions

 ***int unlink(const char *pathname);*** Удаляет имя из файловой системы. Если это имя было последней ссылкой на файл и больше нет процессов, которые держат этот файл открытым, данный файл удаляется и место, которое он занимает освобождается для дальнейшего использования.

Функция ***pid_t waitpid(pid_t pid, int *status, int options); *** приостанавливает выполнение текущего процесса до тех пор, пока дочерний процесс, указанный в параметре pid, не завершит выполнение, или пока не появится сигнал, который либо завершает текущий процесс либо требует вызвать функцию-обработчик.

Функция ***pid_t wait(int *status);*** приостанавливает выполнение текущего процесса до тех пор, пока дочерний процесс не завершится, или до появления сигнала, который либо завершает текущий процесс, либо требует вызвать функцию-обработчик. Если дочерний процесс к моменту вызова функции уже завершился (так называемый "зомби" ("zombie")), то функция немедленно возвращается. Системные ресурсы, связанные с дочерним процессом, освобождаются.

***int dup(int oldfd);*** и ***int dup2(int oldfd, int newfd);*** создают копию файлового дескриптора oldfd.
Старый и новый дескрипторы можно использовать друг вместо друга. Они имеют общие блокировки, указатель позиции в файле и флаги; например, если позиция в файле была изменена с помощью lseek, на одном из дескрипторов, то эта позиция также меняется и на втором.

dup и dup2 возвращают новый дескриптор или -1, если произошла ошибка (в этом случае errno устанавливается должным образом).

int execve(const char *filename, char *const argv [], char *const envp[]); выполняет программу, заданную параметром filename. Программа должна быть или двоичным исполняемым файлом, или скриптом, начинающимся со строки вида "#! интерпретатор [аргументы]". В последнем случае интерпретатор -- это правильный путь к исполняемому файлу, который не является скриптом; этот файл будет выполнен как интерпретатор [arg] filename.

При успешном завершении execve() не возвращает управление, при ошибке возвращается -1, а значение errno устанавливается должным образом. 

***pid_t fork(void);*** создает процесс-потомок, который отличается от родительского только значениями PID (идентификатор процесса) и PPID (идентификатор родительского процесса), а также тем фактом, что счетчики использования ресурсов установлены в 0. Блокировки файлов и сигналы, ожидающие обработки, не наследуются.
Под Linux fork реализован с помощью "копирования страниц при записи" (copy-on-write, COW), поэтому расходы на fork сводятся к копирования таблицы страниц родителя и созданию уникальной структуры, описывающей задачу. 

При успешном завершении родителю возвращается PID процесса-потомка, а процессу-потомку возвращается 0. При неудаче родительскому процессу возвращается -1, процесс-потомок не создается, а значение errno устанавливается должным образом.

## Open
Режимы

O_CREAT - если файл не существует, то он будет создан

O_WRONLY - открыть только для записи

O_TRUNC - если файл уже существует, позволяет записывать в этот файл

Символьные константы для создаваемого файла

S_IRUSR - права на чтение
S_IWUSR - права на запись в файл
S_IRGRP - права на чтение для группы
S_IWGRP - права на запись для группы
S_IROTH - права на чтение для всех

## Access

***int access(const char *pathname, int mode);*** проверяет, имеет ли процесс права на чтение или запись. Проверяет, существует ли файл с именем pathname. Если pathname является символьной ссылкой, то проверяются права доступа к файлу, на который она ссылается.

В случае успеха (есть все запрошенные права) возвращается нуль. При ошибке (по крайней мере один запрос прав из mode был неудовлетворен, или случилась другая ошибка), возвращается -1, а errno устанавливается должным образом. 

F_OK - проверяет существование файла.

## dup2

***int dup2(int oldfd, int newfd);*** делает newfd копией oldfd, закрывая newfd, если требуется

## execve

int execve(const char *filename, char *const argv [], char *const envp[]);   выполняет программу, заданную параметром filename.

##

fork запускаем два процесса для двух команд в одной программе

## Вербальное описание программы

Функция main

    1) Открывает исходный файл
    2) Открывает файл вывода (создает, если такого нет)
    3) Создает копию файлового дескриптора

## Мозговой штурм

 Для выполнение каждой команде нужны входные и выходные данные.

 ### I

 infile является входными данными для cmd1 -> cmd 1 выполняется -> результат работы cmd 1 записывается в end[1].

end[0] прочичитывает результат работы cmd1 из end[1] и передает его в cmd2 -> cmd2 выполняется -> outfile

### II

pipe() связывает массив интов(в данном случае end[2]) в трубу. Все что происходит в end[0] видно в end[1] и наоборот + pipe назначает fd для каждого конца.

pipe мы будем заполнять процессами, которые появляются из fork.

### III

После заполнения концов трубы, родительский процесс end[0] будет считывать, дочерний end[1] будет записывать. Для чтения чего-то, нжно, чтобы это "чего-то" было для начала записано. cmd1 будет исполняться ребенком, cmd2 родителем.

### IV

Для работы трубе нужны дескрипторы, которые мы получим, открывая файл. Так как в linux уже предусмотрены дескрипторы 0 - stdin, 1 - stdout и 2 - stderr, то следовательно, infile - 3, outfile - 4. (end[0] - 5, end[1] - 6).

Для дочернего процесса мы хотим, чтобы infile был stdin и end[1] был stdout для того, чтобы записать результат работы cmd1 в end[1] и родительский процесс мог его прочитать.

С другой стороны, в родительском процессе мы хотим, чтобы end[0] был stdin (end[0] в этот момент ажу прочитает результат работы cmd1 из end[1]), а stdout для cmd2 будет outfile.






    https://csnotes.medium.com/pipex-tutorial-42-project-4469f5dd5901