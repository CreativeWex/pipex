# pipex-WIP ♅
Summary: This project is the discovery in detail and by programming of a UNIX mechanism

## Objectives 

Your objective is to code the Pipex program.
It should be executed in this way:

``./pipex file1 cmd1 cmd2 file2``

Just in case: file1 and file2 are file names, cmd1 and cmd2 are shell commands with
their parameters.
<br>
<br>
The execution of the pipex program should do the same as the next shell command:
``< file1 cmd1 | cmd2 > file2``

## Allowed functions

***int access(const char *pathname, int mode);*** проверяет, имеет ли процесс права на чтение или запись, или же просто проверяет, существует ли файл (или другой объект файловой системы), с именем pathname. Если pathname является символьной ссылкой, то проверяются права доступа к файлу, на который она ссылается.

В случае успеха (есть все запрошенные права) возвращается нуль. При ошибке (по крайней мере один запрос прав из mode был неудовлетворен, или случилась другая ошибка), возвращается -1, а errno устанавливается должным образом. 

Вызов ***open()*** используется, чтобы преобразовать путь к файлу в описатель файла (небольшое неотрицательно целое число, которое используется с вызовами read, write и т.п. при последующем вводе-выводе).

 ***int unlink(const char *pathname);*** Удаляет имя из файловой системы. Если это имя было последней ссылкой на файл и больше нет процессов, которые держат этот файл открытым, данный файл удаляется и место, которое он занимает освобождается для дальнейшего использования.

Функция ***pid_t waitpid(pid_t pid, int *status, int options); *** приостанавливает выполнение текущего процесса до тех пор, пока дочерний процесс, указанный в параметре pid, не завершит выполнение, или пока не появится сигнал, который либо завершает текущий процесс либо требует вызвать функцию-обработчик.

Функция ***pid_t wait(int *status);*** приостанавливает выполнение текущего процесса до тех пор, пока дочерний процесс не завершится, или до появления сигнала, который либо завершает текущий процесс, либо требует вызвать функцию-обработчик. Если дочерний процесс к моменту вызова функции уже завершился (так называемый "зомби" ("zombie")), то функция немедленно возвращается. Системные ресурсы, связанные с дочерним процессом, освобождаются.

***int dup(int oldfd);*** и ***int dup2(int oldfd, int newfd);*** создают копию файлового дескриптора oldfd.
Старый и новый дескрипторы можно использовать друг вместо друга. Они имеют общие блокировки, указатель позиции в файле и флаги; например, если позиция в файле была изменена с помощью lseek, на одном из дескрипторов, то эта позиция также меняется и на втором.

dup и dup2 возвращают новый дескриптор или -1, если произошла ошибка (в этом случае errno устанавливается должным образом).

int execve(const char *filename, char *const argv [], char *const envp[]); выполняет программу, заданную параметром filename. Программа должна быть или двоичным исполняемым файлом, или скриптом, начинающимся со строки вида "#! интерпретатор [аргументы]". В последнем случае интерпретатор -- это правильный путь к исполняемому файлу, который не является скриптом; этот файл будет выполнен как интерпретатор [arg] filename.

При успешном завершении execve() не возвращает управление, при ошибке возвращается -1, а значение errno устанавливается должным образом. 

***pid_t fork(void);*** создает процесс-потомок, который отличается от родительского только значениями PID (идентификатор процесса) и PPID (идентификатор родительского процесса), а также тем фактом, что счетчики использования ресурсов установлены в 0. Блокировки файлов и сигналы, ожидающие обработки, не наследуются.
Под Linux fork реализован с помощью "копирования страниц при записи" (copy-on-write, COW), поэтому расходы на fork сводятся к копирования таблицы страниц родителя и созданию уникальной структуры, описывающей задачу. 

При успешном завершении родителю возвращается PID процесса-потомка, а процессу-потомку возвращается 0. При неудаче родительскому процессу возвращается -1, процесс-потомок не создается, а значение errno устанавливается должным образом.  